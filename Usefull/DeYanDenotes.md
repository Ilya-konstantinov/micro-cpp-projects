Горячие клавиши: 
F2 — поменять имя файла 

Ctrl + shift + n — открыть новое окно 
Ctrl + \ — новое окно
Ctrl + / - разбить окно на два
Ctrl + tab — переключение между окнами 
Ctrl + shift + p — открывает панель доступа
Ctrl + w — закрыть вкладку 
Ctrl + arrows left/right — указатель через слово 
Shift + arrows left/right — выделения блока текста 
Ctrl + shift + arrows left/right — выделение с перескакиванием через слово 
F5 — запуск кода

Как идёт запуск кода? 
Код -> линковка -> прекомпиляция -> ассемблирование

Прекомпиляция:
Раскрытие #include (около 36 тыс. строк кода)
Если писать #include "bits/stdc++.h" вместо #include, всё уже включено, но занимает 130 тыс. строк (сильно дольше)
ООП: 
Чем структура отличается от класса? 
В классе данные могут зависеть друг от друга. 
Для класса мы пишем методы (функции) внутри класса 
В структуре функции пишутся вне структуры.

Конструктор:
имя класса и переменные, которые нужны обязательно задавать какие-то данные, без них код не работает вызывается при "рождении" переменной. 
Деструктор:
~имя класса и всё. он ничего не принимает вызывается при "смерти" переменной (заканчивается область видимости).
Public: Можно во всем коде менять переменные в паблике
Private: Методы, которые нельзя менять вне методов класса

Геттеры: функции, которые выводят данные. с ними нельзя вывести данные просто через переменную, нужно вызвать функцию.

Пример:
int GetHealth() {
        return health;
}
Сеттеры: функция, которая принимает данные
void SetHealth(int health_) {
        health = health_;
        health = std::min(100, health);
}
*Пишутся Get/Set + имя переменной

Константные функции: пишем перед скобкой, когда в функции никак не меняются данные.

Пример: 
void print() const {
        std::cout << "person " << name;
        if (home) std::cout << " who was born in " << home->GetTitle();
        if (is_alive) {
            std::cout << " with health = " << health;
        } else {
            std::cout << " is dead";
        }
        std::cout << '\n';
}

Чтобы объекты не копировались и не вызывались по несколько раз, логичнее передавать ссылки(int&) и принимать указатели(int*)!

Разделение объявления переменных: 
Например когда классы зависят друг от друга, так что нельзя писать их друг перед другом. 
Для этого мы объявляем классы в самом начале с объявлением их методов, но без внутренностей. 
После расписываем методы отдельно как функции, но с "название класса:" в начале.
Пример:
class City 
{
private: 
        std::vector<Citizen*> people;
        std::string title;
public:
        City(std::string title_ );
        std::string GetTitle();
        void print();
        void AddResident(Citizen* person);
}; 
City::City(std::string title_) : title(title_) {
}
std::string City::GetTitle() {
        return title;
}
void City::print() {
        for (const Citizen* person : people) {
                person->print(); // <=> (*person).print();
        }
}

void City::AddResident(Citizen *person) {
        people.push_back(person);
        person->SetHome(this); // <-- поговорим потом
}